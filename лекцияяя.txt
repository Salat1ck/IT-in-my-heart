ПОСЛЕ БАЗ ДАННЫХ

4 модуль разработка клиент серверного приложения
клиент frontend
сервер backend


REACT


Backend сервер - это сервер + серверное приложение + бизнес логика (сценарии обработки клиентских запросов) 


ТЕХНОЛОГИЧЕСКИЕ СТЭК РАЗРАБОТКИ 
-----------------
P E R N + (O R M - sequelize)

P - PostgreSQL
E - Express
R - React
N - NodeJS
-----------------

NodeJS - платформа позволяющая языку JS работать вне браузера 
Главная особенность:
Асинхронность и событийно-ориентированная архитектура 


Основные параметры:

1. не блокирующий ввод/вывод (Когда серверу нужно выполнить операцию ввода/вывода (прочитать файл с диска или сделать запрос к БД) оно не ждёт её завершения, вместо этого он продолжает выполнять другой код, как только операция завершается, вызывается спец. функция-обработчик (callback))
Однопоточность с циклом событий
Цикл событий - механизм, который постоянно проверяет, завершились ли какие-либо асихронные операции
Асихронные операции - операция, которая выполнится когда-нибудь 
2. N P M - менеджер пакетов, который позволяет легко устанвить и использовать в своём проекте открытые библиотеке и инструменты 



ЭТАП 1: 

1. Создание директорий проекта (Папки клиент, сервер)

1) Инициализация прокета

2) Установка необходимых зависимостей (модулей)

2. Создание базового HHTP express  - импорт frameork'а express, определение порта на котором сервер принимает входящие подключения 

Создание переменного окружения 

Создание файла конфигурации базы данных

Настройка промежуточного ПО (Middle wear)

3. Описание модели данных (с помощью sequelize)
 

Работа с таблицами бд как с js объектами 


4. Создание маршрутов (roates) и API поинтов



---------------------------------------

case №1

HTML
-----
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="./style.css">
    <title>Document</title>
</head>
<body>
    <table>
        <thead>
            <tr>
                <td>
                    ID
                </td>
                <td>
                    name
                </td>
                <td>
                    age
                </td>
            </tr>
        </thead>
        <tbody id = 'tbody'>
            
        </tbody>
    </table>
    <script src="./script.js"></script>
</body>
</html>

---
JS
----
const dataset = [
    { id: 1, name: 'Ivanov', age: 30 },
    { id: 2, name: 'Petrov', age: 24 },
    { id: 3, name: 'Sidorov', age: 10 }
]

const table = (data) => {
const tbody = document.getElementById('tbody')
data.forEach(el => {
tbody.innerHTML +=` <tr>
<td> ${el.id} </td> 
<td> ${el.name} </td> 
<td> ${el.age} </td></tr>`    
})};
table(dataset)

Данное решение не является оптимальным, потому что количество атрибутов получается фиксированно. В коде есть уязвимость. передача данных через InnerHTML создает xss уязвимость (другие люди могут ввести нужный запрос и получить нужные данные)
Поэтому необходимо рассмотреть другие варианты реализации



CASE №2 (Исключение xss уязвимость) 


const dataset = [
    { id: 1, name: 'Ivanov', age: 30 },
    { id: 2, name: 'Petrov', age: 24 },
    { id: 3, name: 'Sidorov', age: 10 }
]

const table = (data) => {
const tbody = document.getElementById('tbody')
data.forEach(element => { 
const tr = tbody.insertRow()
const cellId = tr.insertCell()
cellId.textContent = element.id
const cellName = tr.insertCell()
cellName.textContent = element.name
const cellAge = tr.insertCell()
cellAge.textContent = element.age
})
}
table(dataset)






CASE №3

const table = (data) => {
const tbody = document.getElementById('tbody')
data.forEach(element => { 
const tr = tbody.insertRow()
})
el.forEach(item => {
    const td = tr.insertCell()
    td.textContent = element(item)
})
}



Написать функцию которая позволит фильтровать данные


создаем общую папку
делаем папки server и client
открываем папку в виде терминала (правая кнопка по папке)
пишем npm init -y
 

npm install express, dotenv pg(является драйвером для подключения к бд через postgresql) sequelize, cros (необходим для внешних подключений) -D nodemon

http://localhost/3000/...


сommon js
const express = require('express')

ESM
import express from express

import {Start} from (.../server/start.js)
---------------------------------------------
ESM
export default Express
export {Start}
export const Start =>()=>{}

common js

"type": "module",
"dev": "nodemon index.js"

PACKAGE.JSON
------------
{
  "name": "server",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "dev": "nodemon index.js"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "type": "module",
  "devDependencies": {
    "cros": "^1.1.0",
    "dotenv": "^17.2.3",
    "express": "^5.2.1",
    "nodemon": "^3.1.11",
    "pg": "^8.17.2",
    "sequelize": "^6.37.7"
  }
}

---------------------------------------------


npm run dev